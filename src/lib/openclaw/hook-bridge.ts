/**
 * OpenClaw → Agent Forge Hook Bridge
 *
 * This module provides a function to install/configure an OpenClaw hook
 * that forwards incoming channel messages (Telegram, WhatsApp, Discord)
 * to the Agent Forge `/api/openclaw/webhook` endpoint.
 *
 * Instead of OpenClaw's built-in LLM pipeline, messages are routed through
 * Agent Forge's own processMessage (which handles wallet context injection,
 * transaction execution, multi-provider fallback, etc.)
 *
 * How it works:
 * 1. OpenClaw receives a message from a channel (e.g. Telegram)
 * 2. The hook intercepts the message before OpenClaw's built-in agent processes it
 * 3. The hook POSTs the message to our /api/openclaw/webhook
 * 4. Agent Forge processes it through our LLM + transaction pipeline
 * 5. The response is sent back via the channel through OpenClaw
 */

import { readFile, writeFile, mkdir } from "fs/promises";
import path from "path";

const OPENCLAW_STATE_DIR = process.env.OPENCLAW_STATE_DIR || `${process.env.HOME}/.openclaw`;
const HOOKS_DIR = path.join(OPENCLAW_STATE_DIR, "hooks");

const FORGE_WEBHOOK_URL = process.env.NEXT_PUBLIC_APP_URL
  ? `${process.env.NEXT_PUBLIC_APP_URL}/api/openclaw/webhook`
  : "http://localhost:3000/api/openclaw/webhook";

/**
 * Generate the hook script content that forwards messages to Agent Forge.
 */
function generateHookScript(webhookUrl: string, webhookToken?: string): string {
  return `/**
 * OpenClaw → Agent Forge Bridge Hook
 * Auto-generated by Agent Forge. Do not edit manually.
 *
 * This hook intercepts incoming channel messages and routes them
 * through Agent Forge's LLM + blockchain transaction pipeline.
 */

module.exports = {
  name: "agentforge-bridge",
  version: "1.0.0",
  description: "Routes channel messages through Agent Forge",

  hooks: {
    // Intercept incoming messages before the built-in agent
    "message:incoming": async (context) => {
      const { message, channel, sender } = context;

      // Only intercept if it's a real user message (not system/bot)
      if (!message?.text || sender?.isBot) return;

      try {
        const response = await fetch("${webhookUrl}", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            ${webhookToken ? `"Authorization": "Bearer ${webhookToken}",` : ""}
          },
          body: JSON.stringify({
            channel: channel?.type || "unknown",
            senderId: sender?.id,
            senderName: sender?.name || sender?.username,
            message: message.text,
            agentId: context.agentId || "main",
          }),
        });

        if (response.ok) {
          const data = await response.json();
          if (data.response) {
            // Replace the built-in agent response with ours
            context.reply = data.response;
            context.handled = true;
          }
        }
      } catch (err) {
        console.error("[AgentForge Bridge] Webhook error:", err.message);
        // Fall through to built-in agent on error
      }
    },
  },
};
`;
}

/**
 * Install the Agent Forge bridge hook into OpenClaw.
 */
export async function installBridgeHook(options?: {
  webhookUrl?: string;
  webhookToken?: string;
}): Promise<{ success: boolean; message: string; hookPath?: string }> {
  const url = options?.webhookUrl || FORGE_WEBHOOK_URL;
  const token = options?.webhookToken || process.env.OPENCLAW_WEBHOOK_TOKEN;

  try {
    // Ensure hooks directory exists
    const hookDir = path.join(HOOKS_DIR, "agentforge-bridge");
    await mkdir(hookDir, { recursive: true });

    // Write the hook script
    const hookPath = path.join(hookDir, "index.js");
    const script = generateHookScript(url, token);
    await writeFile(hookPath, script, "utf-8");

    // Write package.json for the hook
    const pkg = {
      name: "agentforge-bridge",
      version: "1.0.0",
      description: "Routes OpenClaw channel messages through Agent Forge",
      main: "index.js",
    };
    await writeFile(
      path.join(hookDir, "package.json"),
      JSON.stringify(pkg, null, 2),
      "utf-8"
    );

    return {
      success: true,
      message: `Bridge hook installed at ${hookPath}. Run "openclaw hooks enable agentforge-bridge" to activate.`,
      hookPath,
    };
  } catch (err) {
    return {
      success: false,
      message: err instanceof Error ? err.message : String(err),
    };
  }
}

/**
 * Check if the bridge hook is installed.
 */
export async function isBridgeHookInstalled(): Promise<boolean> {
  try {
    const hookPath = path.join(HOOKS_DIR, "agentforge-bridge", "index.js");
    await readFile(hookPath, "utf-8");
    return true;
  } catch {
    return false;
  }
}

